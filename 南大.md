# 编程题

## 第一次练习题

### 1.求数字N的二进制中1的个数

边界条件：n=0

递归返回段：reutrn n

递归前进段：前n-1位中1的个数 + 最后一位1的个数，即count(n/2) + n%2;

```
public class Count {
    public int count(int n) {
        if (n == 0) {
            return 0;
        } else {
            return count(n/2) + n%2;
        }
    }
}
```



# 真题

## 2003年

最坏情况中时间效率和空间效率最高的排序：堆排序

解决互斥和同步的基本机制：信号量、临界区、消息传递



二叉树节点结构为（left，data，right），求层数

思想：

```
if (空树) {
	return 0;
}
递归求左子树高度；
递归求右子树高度；
return 左子树、右子树高度的较大值+1；
```

代码：

```
class BSTNOde {
	int data;
	BSTNOde left;
	BSTNOde right;
}

int getHeight(BSTNode root) {
	if (root == null) {
		return 0;
	}
	int leftHeight = getHeight(root.left);
	int rightHeight = getHeight(root.right);
	return leftHeight > rightHeight ? leftHeight+1 : rightHeight+1;
}
```


斐波那契数列递归计算F(n)的时间复杂度：O(2^n^)

B树查找最多读盘次数（最高层数）：1+log~m/2~[(n+1)/2]

文件目录的功能

1. 将文件名转换为文件在外存的物理位置，实现按名存取（最基本功能）
2. 合理组织目录结构，提高对目录检索速度
3. 文件共享
4. 允许文件重名



虚拟存储器？引入虚拟存储器的好处？

* 虚拟存储器：当内存快耗尽时，就从内存中选择某些页面换出，并从外存中选择某些页面换入到内存；
* 好处：扩展逻辑地址空间、简化存储器管理、内存保护



电梯调度的基本思想：没有请求时，磁头不动；有请求时，磁头沿着一个方向移动。当该方向上仍有请求时，磁头继续沿着该方向移动；当该方向上没有请求时，磁头折回向相反方向移动。



## 2004年

n个盘子的汉诺塔的移动次数：2^n^-1



* 交换二叉树各结点左右子树

思想：

```
if (左右子树都为空) {
	return;
} else {
	交换左右子树;
}
if (左子树不为空) {递归左子树;}
if (右子树不为空) {递归右子树;}
```

代码：

```
public void switchLR(BSTNode root) {
	if (root.left==null && root.right==null) {
		return ;
	} else {
		BSTNode temp = root.left;
		root.left = root.right;
		root.right = temp;
	}
	if (root.left != null) {switchLR(root.left;)}
	if (root.right != null) {switchLR(root.right;)}
}
```



* 循环队列（只有rear和length属性）判空、判满、出队，入队

```
    int rear;
    int[] a;
    int front;
    public Queue(int m) {
        this.maxSize = m;
        this.rear = -1;
        this.length = 0;
        this.front = (this.rear + 1 + this.maxSize - this.length) % this.maxSize;
        a = new int[maxSize];
    }

    //判断队空
    public boolean isEmpty() {
        return length == 0 ? true : false;
    }

    //判断队满
    public boolean ifFull() {
        return length == maxSize ? true : false;
    }

    //入队
    public void EnQueue(int num) {
        if (ifFull()) {
            throw new RuntimeException("队列已满，无法插入元素");
        }
        rear = (rear + 1) % maxSize;
        length++;
        a[rear] = num;
    }

    //出队
    public int DeQueue(int num) {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        num = a[front];
        front = (front+1) % maxSize;
        length--;
        return num;
    }
}
```



什么是虚拟设备，举例：用虚拟技术将一台独占设备→多台逻辑设备，供多个用户同时使用。如虚拟光驱、虚拟网卡。

什么是虚拟存储器，举例：能够自动实现部分装入和部分替换功能，提供比物理内存大得多的逻辑地址空间的存储器。如Windows的“虚拟内存“、Linux的”交换空间“。

什么是文件的物理结构，举例（3个）：文件在物理存储空间上的存储方法和组织关系。如顺序文件、链接文件、索引文件。

时间片调度算法：为每个进程分配相等的时间片，当某进程的时间片用完后，就移动到就绪队列尾部，等待下一轮调度。

文件保护的基本方法：

* 口令保护、加密保护：防止他人存取/窃取
* 访问控制：控制用户对文件的访问方式

中断源的类型

1. 外部设备请求中断：外设完成自身的操作后，向CPU发送中断请求，要求CPU为其服务；
2. 故障强迫中断：计算机硬件异常或故障引起的中断
3. 实时时钟请求中断：达到规定时间，时钟电路发出中断请求，CPU完成检测和控制工作；
4. 数据通道中断（DMA）：外设直接与存储器交换数据
5. 程序自愿中断：CPU执行特殊指令（自陷指令）或硬件电路引起的中断；



一个生产者、两个消费者共享5个缓冲区

```
item B[5];
semaphore empty=5, full=0;
semaphore mutex_c = 1, mutex = 1;
int put = 0, get = 0;
process producer() {
	while (true) {
		p(empty);
		P(mutex);
		B[put] = 1;
		put = (put+1)%5;
		V(mutex);
		V(full);
	}
}
process consumer() {
	while (true) {
		P(full);
		P(mutex);
		P(mutex_c);	//消费者之间互斥
		B[get] = 0;
		get = (get+1)%5;
		V(mutex_c);
		V(mutex);
	}
}
```



## 2005年

不必完成全部排序，就能找到最大/最小元素：直接选择排序、冒泡排序、堆排序

prim算法适用于稠密图，kruscal算法适用于稀疏图

构造具有最小带权路径长度的4叉树：要求所有结点的度都是4，必须在前面补0（p397）

地址转换（重定位）？写出两种重定位方式

简述SPOOLing系统的工作方式

文件的逻辑结构？写出两种文件的逻辑结构？

* 文件逻辑结构是从用户角度出发，研究用户眼中的信息组织方式
* 分类：1.流式文件——无结构文件，一串顺序的信息组合；2.记录式文件——有结构文件，包含若干记录；

进程通信的2条基本原语：

* send：
* receive



* 判断回文序列（递归法）

思想：

```
if (首元素下标>=尾元素下标) {
	return true;
} 
if(首元素==尾元素){
	递归判断中间序列；
}else{
	return false;
}
```

代码：

```
public static boolean palindrome(String str,int low, int high){
		if(low >= high){
			return true;
		}
		if(str.charAt(low)==str.charAt(high)){
			return palindrome(str, low++, high--);
		}else{
			return false;
		}
}
```



* 设二叉树结构为（firstchild，data，nextsibling，degree），firstchild和nextsibling分别指向该结点的第一个子女和下一个右兄弟，求各结点的度数

思想：

```
if (当前结点为空) {
	return 0;
}
度数初始化为0;
if (孩子不为空) {
	度数加1;
}
while (右兄弟不为空) {
	度数加1;
	找下一个右兄弟;
}
递归孩子;
递归右兄弟;
返回度数;
```

代码：

```
class BSTNode {
    int data;
    int degree;
    BSTNode firstchild;
    BSTNode nextsibling;

    public int degree(BSTNode root) {
        if (root == null) {
            return 0;
        }
        root.degree = 0;
        if (root.firstchild != null) {
            root.degree++;
        }
        BSTNode p = root.firstchild.nextsibling;
        while (p.nextsibling != null) {
            root.degree++;
            p = p.nextsibling;
        }
        degree(root.firstchild);
        degree(root.nextsibling);
        return root.degree;
    }
}
```



## 2006年

空间复杂度最小的排序算法：直接插入排序，至少用n+1个内存单元，时间复杂度是O(n^2^)

队列首元素的位置：(rear-length+1)%maxSize

* 链表反转

思想：1→2→3，1←2→3，1←2←3

```
//非递归
if(链表为空) {
	return null;
}
初始化上一节点、当前结点、下一节点;
while(当前结点不为空) {
    获取当前结点的下一节点;
    将当前节点的指针反转;
    上一节点、当前结点指针后移;
}
头结点→尾结点;

//递归
if (链表为空 || 只有一个结点) {
	return 头结点;
}
递归将后面n-1个结点反转，将原表尾结点→新表头结点;
原表头结点→新表尾结点(两步);
return 新表头结点;
```

代码：

```
//非递归
public static Node reverse(Node head) {  
	if (head == null){  
        return head;  
    }
    Node pre = head;// 上一结点        
    Node cur = head.next;// 当前结点      
    Node tmp;// 临时结点，用于保存当前结点的指针域（即下一结点）  
    while (cur != null) {// 当前结点为null，说明位于尾结点  
        tmp = cur.next;  
        cur.next = pre;
        pre = cur; 
        cur = tmp; 
    }  
    head.next = null;  
    return pre;  
}  

//递归
private static Node reverse(Node head) {
    /*如果是空链或者只是单个节点的链表  将直接返回*/
    if(head == null || head.getNext() ==null) {
        return head;
    }
    Node reverse = reverse(head.next());
    head = head.next.next;
    head.next = null;   
    return reverse;   
}
```



* 树的结构为(firstchild, data, nextsibling)，firstchild、nextsibling分别指向该结点第一个孩子、下一个兄弟，求树的高度

思想：

 代码：



## 2007年

广义表中的元素可以是原子或子表，因此广义表可以用链表表示

队列元素总数：(rear-front+maxSize)%maxSize

一棵树无论先序/中序/后序，叶结点的相对次序不变（LR）

森林中非叶节点的个数为F，对应二叉树中没有右孩子的结点个数为B，则B=F+1

死锁的处理方法：预防死锁（破坏4个必要条件之一），避免死锁（银行家算法），检测和解除死锁（进程回退法、进程撤销法、资源剥夺法、系统重启法）

文件的物理结构：文件在物理存储介质上的存放方法和组织方法

* 计算法：通过计算得到物理地址，从而找到原纪录
* 指针法：设置指针，指示物理地址+记录间的关联

FIFO置换算法：置换**这三页中**，最先进入的那页



## 2008年

递归计算最大子序列和的时间复杂度：O(nlog~2~n)

高度为h（根结点为第0层）的完全二叉树至少有2^h^个结点，至多有2^h+1^-1个结点

高度为h的二叉树至少有2h-1个结点，至多有2^h+1^-1个结点

从一棵空AVL树开始，一次插入一个关键码，使四种平衡（LL,LR,RR,RL）各至少执行一次，至少需要多少关键码？写一个关键码序列？

* 除根节点外在原有基础上至少两个结点才能使得其不平衡，因此  1 + 2 * 4 = 9，所以应为至少9个
* 举例：ABCCEFIKLM


对于下列的文件物理结构，修改第25个文件需要启动磁盘的次数

1. 顺序文件：1次
2. 链接文件：25次
3. 索引文件：2次（一次读索引，一次读第25块）



## 2013年

对称矩阵第i行第j列的元素存放在一位数组B的下标（下标都从0开始）：B[i*(i+1)/2+j]

比较次数与初始位置无关的排序：直接选择排序，二分插入排序

类XmlEditor的父类最好命名为：Editor（见名知意）

假设学生的年龄范围为16-40，可以划分为1个有效等价类 [16,40]，两个无效等价类 (-∞,16)、(40,+∞)

结对编程：两个程序员协作编程，一个驾驶员（Driver）负责输入代码，一个观察员（Observer）进行评审，两者可以交换

重构：不改变软件系统的功能，而改进其内部结构，提升代码质量

测试驱动开发要求：程序员编写代码前，优先完成该段代码的测试代码，而不是测试用例

代码评审的速度要求：不是越快越好，而要用足够的时间进行正确的评审，单不超过60-90min/次

桩：在软件测试中用于替换某些模块。桩和被替换的模块有相同的接口，可以模拟模块的行为，比模块更简单。

软件项目管理：项目启动、项目计划、项目执行、项目跟踪与控制。项目收尾。

软件生存周期过程中，修改错误代价最大的阶段是：发布运行阶段

核心态（管态）操作：进程管理，内存管理，I/O管理，中断

N个结点的星型拓扑有N-1条物理链路（总站在中心）

UDP数据报的最短长度：8B

封装：把数据打包在一个特定的协议报头中

IOS镜像可以从RAM、闪存、TFTP下载，不能从NVRAM下载。

NVRAM：非易失性RAM，用于存放配置文件。

私网地址

 * 10.0.0.0~10.255.255.255.255
 * 172.16.0.0~172.31.255.255
 * 192.168.0.0~192.168.255.255

实现私网和公网的转换：NAT

指定端口：被选定为在某个网段转发流量的交换机端口。

STP端口的五个状态：阻塞、监听、学习、转发、禁止



AVL树插入:p268

设计有理数及其四则运算的类，并进行单元测试：p269

正方形不能继承长方形
* 答题格式：不可以+违反···原则+解释原则
* 实现正方形类代码
* 画类图

页面替换算法：OPT、FIFO、LRU



设计测试代码

* 设计测试用例：建议用表格呈现给老师；输出输出既要考虑合法情况，又要考虑不合法情况；建议采用等价类划分
* 设计测试代码：根据测试用例表设计测试代码；类名建议用Test，方法名建议用test1、test2····；每个方法添加注解@Test

表格：（ID，输入，预期输出）



划分子网：把192.168.10.0/24分配给A（60台主机）、B（12台主机）、C（31台主机）、D（6台主机）

 * A：由于60<2^6^-2-1，故网络地址为192.168.10.0/26（后六位给主机），主机地址为192.168.10.1/26~192.168.10.60/26（共60个），后面4个IP地址空闲不用；减2是因为主机号全为1和全为0不能用，减1是给路由器分配一个地址；
 * C：由于31<2^6^-2-1，故网络地址为192.168.10.64/26（后六位给主机），主机地址为192.168.10.65/26~192.168.10.95/26（共31个），后面33个IP地址不用
 * B：网络地址为192.168.10.128/28，主机地址为192.168.10.129/28~192.168.10.140/28
 * D：网络地址为192.168.10.144/28，主机地址为192.168.10.145~192.168.10.151./28



## 2014年

一元多项式加减法的时间复杂度O(m+n)，乘法的时间复杂度O(mn)

B树的高度：logm(n+1)≤h≤logm/2((n+1)/2)+1演

化模型是需求驱动的，瀑布模型是文档驱动的，螺旋模型是风险驱动的，敏捷过程是以人为核心驱动的

直接插入排序比较次数n-1，快速排序比较次数n(n-1)/2

判断需求书写是否正确：不能用模糊词语，不能让软件限制用户

软件体系结构构成：部件、连接件、配置

属于需求分析阶段的文档内容——系统顺序图、分析类图；属于软件详细设计阶段的文档内容——代码设计顺序图、设计类图、包图。

判断内聚：p287-16

SRP：单一指责原则。一个类只有一个功能不一定符合SRP，因为这仅仅是功能内聚，没有指明信息内聚

最重要的代码质量：易读性

一个类只有顺序语句而没有分支结构，最适合的软件测试技术：语句覆盖

银行家算法：通过破坏循环等待条件来避免死锁

设备驱动程序功能：将用户提交的逻辑I/O请求→物理I/O操作

信号量mutex=0表示：有一个进程在临界区（mutex初值为1）

数据封装顺序（应用层→物理层）：data→segment→package→frame→bits

根据子网掩码判断子网广播地址：主机号全为1

OSPF路由器构建LSDB需要的信息：来自其他路由器的LSA

34

最低逻辑接口地址不能作为路由器ID号。最高逻辑接口地址、最低物理接口地址、最高物理接口地址都可以

PPP协议是一个协议集，它包括：

* LCP：负责协商在PPP连接上传输的数据链路层协议；
* NCP：负责协商在PPP连接上传输的网络层协议；
* PPP扩展协议

IP分组转发时不分段，改变的是TTL、校验和字段，而IP地址、DF、MF不会改变。NAT转换时，IP地址改变

STP（生成树协议）用于解决：广播风暴

无限局域网标准IEEE802.11g规定的最大速率：54Mbps



B树删除：p289

复杂度分析：p290

画分析类图：p291 

代码改进：工厂模式：p292

* 分析代码不足：1.根据内聚耦合分析；2.从面向对象设计原则分析；
* 逻辑内聚和控制耦合的修改：把每个分支抽离出来作为单独的方法

软件体系结构的**分层风格**

* 定义：根据不同的抽象层次将系统组织为层次结构，每个层次被建立为一个部件，不同部件间通过程序调用连接
* 优点：设计简单，便于理解，支持并行并发，复用性好，易修改
* 缺点：交互协议难修改，性能损失，难以确定层次数量和粒度

LAN、VLAN的区别：前者是局域网，后者是虚拟局域网



## 2015年

一棵树中的结点或者是叶结点，或者有两个非空子树，若有编号为0~n-1的n个非叶节点，则：

* 有n+1个叶结点；
* 若根结点层次为0，则各个叶结点的层次之和最多为(n+1)*n/2；

提高Hash表的查找效率：1.降低装填因子α；2.设计冲突少的Hash函数。聚集（堆积）无法避免，不能通过避免堆积来提高查找效率。

需要在核心态执行的操作：进程管理、内存管理、I/O管理、中断

fork()：每fork一次，生成一个现有进程的子进程。n次fork会生成2^n^-1个子进程。进程家族树如下：

![1572836393297](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572836393297.png)

![1572836417305](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572836417305.png)

Linux中stab分配器采用的内存管理方式：伙伴系统

Unix中打开文件的系统调用open输入参数包含文件名，若打开成功则返回文件描述符

路由环路解决方法

1. Defining a Maximum/定义最大跳数(一般为15）： 超过最大跳数则抛弃报文。
2. 路由毒害/ Route Poisoning：当路由信息的跳数超过定义最大跳数时，不是直接从路由表中删除该
   路由信息，而是向相邻路由发送相关路由信息，通知其他路由该路径失效。
3. Split Horizon/水平分割：路由器从某个接口接收到的更新信息不允许再从这个接口发回去。
4. Hold-Down-Fimers计时器：如果一条路由更新的跳数大于路由表已记录的该路由的跳数，启
   动计时器，在计时器超时前，路由器不再接收关于这条路由的更新信息。

设一棵树的节点结构为<firstchild, data, nextSibling>，给出树的类的定义，并计算其高度



代码改进：时间内聚



## 2016年

在O(n)内重排a[0...n-1]，将所有负数排在所有非负值之前

```
//双指针法
设首尾下标low,high
while (low<high) {
    让A[low]为从左到右第一个非负数;
    让A[j]为从右到左第一个负数;
    交换A[low]、A[high];
}
```

软件质量保障的三种手段

* 评审：由作者之外的人检查产品
* 测试：包括单元测试、集成测试、系统测试
* 质量度量：用数字量化的方法描述产品软件

需求判断

- 系统使用6个月后，成本应下降25%：功能需求
- 系统应该能存储5年的销售数据：数据需求
- 销售人员可以使用系统指定销售订单：功能需求
- 系统可以在IOS和Android两种主流移动平台使用：对外接口
- 输入ID时，系统应该显示用户信息：功能需求

以ATM取款为主题，编写取款用例：p324

代码改进（违反单一职责原则）：p324

程序映象组成：程序、数据、栈属性

段页式地址映射：根据段号在段表中查页表，根据页号在页表中查物理块号，物理地址=物理块号×页面大小+偏移量

**I/O层次结构**

* 用户级I/O软件：用户进行I/O系统调用，格式化I/O。大部分运行在核心态，小部分运行在用户态。用户要读/写设备中的内容必须进行——系统调用。
* 设备独立性软件：实现一般性的I/O功能，并向用户级I/O软件提供接口。
* 设备驱动程序：逻辑I/O→物理I/O
* 中断处理程序：当I/O发出中断请求时，暂停现行进程，转而执行中断处理程序；执行完中断处理程序后，再返回原来断点处执行原程序

PPP协议：面向字节的数据链路层协议，应用于直接连接在两点的链路上，通过拨号或专线方式建立点对点连接发送信息。

水平分割：从路由器某接口收到的更新信息不允许再从这个接口发出去。 

**单域OSPF工作过程**

1. OSPF路由器相互发送HELLO报文，建立邻居关系；
2. 相邻路由器间报告自己的链路状态信息（LSA）；
3. 经过LSA洪泛后所有路由器形成统一的LSDB；
4. 根据SPF算法，以自己为根，计算最短生成树，形成路由转发信息；



